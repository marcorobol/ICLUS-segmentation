<!DOCTYPE html>
<html>

<head>
  <link href="Chart.min.css" rel="stylesheet" />
</head>

<body>


<h1>Iclus 2021 data-set platform</h1>

<form action="api/stats" method="get" name="queryform" id="queryform">

  <span>Main Grouping: </span>&emsp;
  <input type='radio' name="mainLabel" checked id="mainLabelByDepth" value="depth"/>
  <span>groupByDepth</span>&emsp;
  <input type='radio' name="mainLabel" id="mainLabelByFrequency" value="frequency"/>
  <span>groupByFrequency</span>&emsp;
  <input type='radio' name="mainLabel" id="mainLabelByPixelDensity" value="pixel_density"/>
  <span>groupByPixelDensity</span>&emsp;
  <input type='radio' name="mainLabel" id="mainLabelByStructure" value="structure"/>
  <span>groupByStructure</span>

  <hr/>

  <span>First Stack: </span>&emsp;
  <input type='radio' name="firstStackingLabel" value="disabled"/>
  <span>disable</span>&emsp;
  <input type='radio' name="firstStackingLabel" value="none"/>
  <span>stackByNone(=Total)</span>&emsp;
  <input type='radio' name="firstStackingLabel" value="depth"/>
  <span>stackByDepth</span>&emsp;
  <input type='radio' name="firstStackingLabel" checked value="frequency"/>
  <span>stackByFrequency</span>&emsp;
  <input type='radio' name="firstStackingLabel" value="pixel_density"/>
  <span>stackByPixelDensity</span>&emsp;
  <input type='radio' name="firstStackingLabel" value="structure"/>
  <span>stackByStructure</span>
  <br/>
  <span>Substack: </span>&emsp;
  <input type='radio' name="firstSubStackingLabel" value="disabled"/>
  <span>disabled</span>&emsp;
  <input type='radio' name="firstSubStackingLabel" value="depth"/>
  <span>substackByDepth</span>&emsp;
  <input type='radio' name="firstSubStackingLabel" value="frequency"/>
  <span>substackByFrequency</span>&emsp;
  <input type='radio' name="firstSubStackingLabel" checked value="pixel_density"/>
  <span>substackByPixelDensity</span>&emsp;
  <input type='radio' name="firstSubStackingLabel" value="structure"/>
  <span>substackByStructure</span>
  <br/>
  <label name="firstStackPlottingValue">Plot # of:</label>
  <select name="firstStackPlottingValue" id="firstStackPlottingValue">
    <option value="number_of_frames" selected>frames</option>
    <option value="number_of_analyses">analyses</option>
    <option value="number_of_patients">patients</option>
    <option value="number_of_operators">operators</option>
  </select>

  <hr/>

  <span>Second Stack: </span>&emsp;
  <input type='radio' name="secondStackingLabel" checked value="disabled"/>
  <span>disable</span>&emsp;
  <input type='radio' name="secondStackingLabel" value="none"/>
  <span>stackByNone(=Total)</span>&emsp;
  <input type='radio' name="secondStackingLabel" value="depth"/>
  <span>stackByDepth</span>&emsp;
  <input type='radio' name="secondStackingLabel" value="frequency"/>
  <span>stackByFrequency</span>&emsp;
  <input type='radio' name="secondStackingLabel" value="pixel_density"/>
  <span>stackByPixelDensity</span>&emsp;
  <input type='radio' name="secondStackingLabel" value="structure"/>
  <span>stackByStructure</span>
  <br/>
  <span>Substack: </span>&emsp;
  <input type='radio' name="secondSubStackingLabel" value="disabled"/>
  <span>disabled</span>&emsp;
  <input type='radio' name="secondSubStackingLabel" value="depth"/>
  <span>substackByDepth</span>&emsp;
  <input type='radio' name="secondSubStackingLabel" value="frequency"/>
  <span>substackByFrequency</span>&emsp;
  <input type='radio' name="secondSubStackingLabel" value="pixel_density"/>
  <span>substackByPixelDensity</span>&emsp;
  <input type='radio' name="secondSubStackingLabel" checked value="structure"/>
  <span>substackByStructure</span>
  <br/>
  <label for="secondStackPlottingValue">Plot # of:</label>
  <select name="secondStackPlottingValue" id="secondStackPlottingValue">
    <option value="number_of_frames">frames</option>
    <option value="number_of_analyses">analyses</option>
    <option value="number_of_patients" selected>patients</option>
    <option value="number_of_operators">operators</option>
  </select>
  
  <hr/>

  <!-- <input type='checkbox' name="groupByDepth" checked id="groupByDepth"/>
  <span>groupByDepth</span>&emsp;
  <input type='checkbox' name="groupByFrequency" checked id="groupByFrequency"/>
  <span>groupByFrequency</span>&emsp;
  <input type='checkbox' name="groupByPixelDensity" id="groupByPixelDensity"/>
  <span>groupByPixelDensity</span>&emsp;
  <input type='checkbox' name="groupByStructure" id="groupByStructure"/>
  <span>groupByStructure</span> -->
  
  <br/>
  <span>roundDepthBy:</span>&ensp;
  <input name="roundDepthBy" value=60 id="roundDepthBy"/>
  <span>roundFrequencyBy:</span>&ensp;
  <input name="roundFrequencyBy" value=4 id="roundFrequencyBy"/>
  <span>roundPixelDensityBy:</span>&ensp;
  <input name="roundPixelDensityBy" value=40 id="roundPixelDensityBy"/>

  <br/>
  <button type="button" onclick="refresh()">Update</button>

</form>

<hr/>

<canvas id="myChart" width="400" height="200"></canvas>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="Chart.min.js"></script>



<script>



var ctx = document.getElementById('myChart').getContext('2d');
var myChart = new Chart(ctx, {
    type: 'bar',
    data: {
        labels: [],
        datasets: []
    },
    options: {
      title: {
          display: true,
          text: 'Data distribution'
      },
      scales: {
          xAxes: [{
            // offset: false,
            // gridLines: {
            //   offsetGridLines: false
            // },
            scaleLabel: {
              display: true,
              labelString: '',
            },
            stacked: true
          }],
          yAxes: [
          {
            scaleLabel: {
              display: true,
              labelString: '# of frames',
            },
            id: 'left-y-axis',
            ticks: {
                beginAtZero: true
            },
            stacked: true,
            type: 'linear'
            // type: 'logarithmic'
          },
          {
            scaleLabel: {
              display: true,
              labelString: '# of patients',
            },
            id: 'right-y-axis',
            position: 'right',
            ticks: {
                beginAtZero: true
            },
            stacked: true,
            type: 'linear'
            // type: 'logarithmic'
          }]
      },
      legend: {
        position: 'bottom'
      },
      hover: {
          animationDuration: 0
      },
      animation: {
          duration: 1000,
          onComplete: function () {
              var chartInstance = this.chart,
                  ctx = chartInstance.ctx;
              ctx.font = Chart.helpers.fontString(Chart.defaults.global.defaultFontSize, Chart.defaults.global.defaultFontStyle, Chart.defaults.global.defaultFontFamily);
              ctx.fillStyle = "black";
              ctx.textAlign = 'center';
              ctx.textBaseline = 'bottom';
              
              this.data.datasets.forEach(function (dataset, i) {
                  var meta = chartInstance.controller.getDatasetMeta(i);
                  meta.data.forEach(function (bar, index) {
                    console.log(bar)
                      var value = dataset.data[index];
                      var short_label = dataset.short_label;
                      if(value>0) ctx.fillText(short_label, bar._model.x, bar._model.y + (bar._view.base-bar._view.y)/2 + 5);
                  });
              });
          }
      }
    }
});



async function callStats({groupBy}) {
  
  // var query_res = [{"depth_grouped":320,"frequency_grouped":4,"number_of_frames":1400,"number_of_files":"14","number_of_analyses":"2","number_of_patients":"2","number_of_operator":"1","operators":[1001]},{"depth_grouped":240,"frequency_grouped":4,"number_of_frames":3900,"number_of_files":"39","number_of_analyses":"4","number_of_patients":"3","number_of_operator":"2","operators":[1001,1206]},{"depth_grouped":160,"frequency_grouped":6,"number_of_frames":35,"number_of_files":"1","number_of_analyses":"1","number_of_patients":"1","number_of_operator":"1","operators":[1001]},{"depth_grouped":160,"frequency_grouped":4,"number_of_frames":32959,"number_of_files":"324","number_of_analyses":"28","number_of_patients":"28","number_of_operator":"3","operators":[1001,1014,1206]},{"depth_grouped":120,"frequency_grouped":null,"number_of_frames":12194,"number_of_files":"76","number_of_analyses":"7","number_of_patients":"7","number_of_operator":"1","operators":[1001]},{"depth_grouped":120,"frequency_grouped":6,"number_of_frames":33336,"number_of_files":"148","number_of_analyses":"17","number_of_patients":"15","number_of_operator":"3","operators":[1001,1014,1255]},{"depth_grouped":120,"frequency_grouped":4,"number_of_frames":63303,"number_of_files":"354","number_of_analyses":"36","number_of_patients":"34","number_of_operator":"2","operators":[1014,1255]},{"depth_grouped":80,"frequency_grouped":null,"number_of_frames":10740,"number_of_files":"67","number_of_analyses":"6","number_of_patients":"5","number_of_operator":"1","operators":[1001]},{"depth_grouped":80,"frequency_grouped":6,"number_of_frames":192712,"number_of_files":"812","number_of_analyses":"65","number_of_patients":"49","number_of_operator":"3","operators":[1001,1014,1255]},{"depth_grouped":80,"frequency_grouped":4,"number_of_frames":85268,"number_of_files":"625","number_of_analyses":"58","number_of_patients":"58","number_of_operator":"4","operators":[1001,1014,1206,1255]},{"depth_grouped":80,"frequency_grouped":2,"number_of_frames":126,"number_of_files":"1","number_of_analyses":"1","number_of_patients":"1","number_of_operator":"1","operators":[1014]},{"depth_grouped":40,"frequency_grouped":10,"number_of_frames":552,"number_of_files":"3","number_of_analyses":"1","number_of_patients":"1","number_of_operator":"1","operators":[1255]},{"depth_grouped":40,"frequency_grouped":6,"number_of_frames":1040,"number_of_files":"5","number_of_analyses":"3","number_of_patients":"3","number_of_operator":"2","operators":[1001,1014]}];
  let queries = []
  // if ($('#groupByDepth')[0].checked)
    // queries.push('groupBy=depth')
  // if ($('#groupByFrequency')[0].checked)
    // queries.push('groupBy=frequency')
  // if ($('#groupByPixelDensity')[0].checked)
    // queries.push('groupBy=pixel_density')
  // if ($('#groupByStructure')[0].checked)
    // queries.push('groupBy=structure')

  for (field of groupBy) {
    if(field=="depth")
      queries.push('groupBy=depth')
    else if(field=="frequency")
      queries.push('groupBy=frequency')
    else if(field=="pixel_density")
      queries.push('groupBy=pixel_density')
    else if(field=="structure")
      queries.push('groupBy=structure')
  }
  
  if ($('#roundDepthBy')[0].value!="null") queries.push('roundDepthBy='+$('#roundDepthBy')[0].value)
  if ($('#roundFrequencyBy')[0].value!="null") queries.push('roundFrequencyBy='+$('#roundFrequencyBy')[0].value)
  if ($('#roundPixelDensityBy')[0].value!="null") queries.push('roundPixelDensityBy='+$('#roundPixelDensityBy')[0].value)

  return query_res = await fetch('../api/stats?'+queries.join('&'))
    .then((resp) => resp.json()) // Transform the data into json
    .catch( error => console.error(error) ); // If there is any error you will catch them here
}



/**
 * This function replot the graph
 */
 async function refresh() {


  
  /**
   * Query to compute all labels
   */
  var query_res = await callStats({groupBy: ['depth', 'frequency', 'pixel_density', 'structure']});
  let labels = {
    depth: [],
    frequency: [],
    pixel_density: [],
    structure: []
  }
  let {depth, frequency, pixel_density, structure} = labels;
  for (row of query_res) {
    for ( let [keys,values] of Object.entries(labels) ) {
      if ( !values.includes(row[keys]) )
        values.push(row[keys])
    }
  }
  for ( let [keys,values] of Object.entries(labels) ) {
    values.sort((a,b)=>a - b)
  }

  

  myChart.data.datasets = [];
  var datasets = myChart.data.datasets;
  

  var stackIndex = 0
  /**
   * Plot multi-stackable datasets
   */  
  async function plotDataset(fields, stackIndexIgnore, number_of='number_of_frames' , yAxisID='left-y-axis') {
    
    console.log(fields)

    var mainField = fields[0]
    var stackField = fields[1]
    var substackField = fields[2]
    
    var mainLabels = labels[mainField]
    var stackLabels = labels[stackField]
    var substackLabels = labels[substackField]
    
    function computeDataset(query_res, comparativeFunction) {
      let data = []
      for (let mainLabel of mainLabels) {
        let value = 0;
        for (let row of query_res) {
          if (comparativeFunction(mainLabel, row)) {//(row[mainField]==mainLabel) {
              value = new Number(row[number_of])
              break;
          }
        }
        data.push(value)
      }
      return data;
    }

    if (fields.length>=1) {
      
      let query_res = await callStats({groupBy: [mainField]});

      stackIndex++

      // plot total
      datasets.push({
        label: 'total '+number_of,
        short_label: 'total',
        data: computeDataset(
          query_res,
          (current_label, current_row) => current_row[mainField]==current_label
        ),
        borderWidth: 1,
        stack: stackIndex,
        // barThickness: 'flex',
        // categoryPercentage: 0.9,
        // barPercentage: 1,
        yAxisID: yAxisID
      });

      if (fields.length>=2) {

        let query_res = await callStats({groupBy: [mainField, stackField]});

        stackIndex++
        var stackIndexStack = stackIndex
        stackIndex++
        var subStackIndexStack = stackIndex
        
        // plot stacks
        for (let stackLabel of stackLabels) {

          datasets.push({
            label: number_of+' given '+stackField+'='+stackLabel,
            short_label: stackField.substring(0,2).toUpperCase()+'='+stackLabel,
            data: computeDataset(
              query_res,
              (current_label, current_row) => current_row[mainField]==current_label && current_row[stackField]==stackLabel
            ),
            backgroundColor: rainbow( stackLabels.length, stackLabels.indexOf(stackLabel), 0.5),
            borderSkipped: '',
            borderWidth: 2,
            stack: stackIndexStack,
            yAxisID: yAxisID
          });

          if (fields.length>=3) {
            
            let query_res = await callStats({groupBy: [mainField, stackField, substackField]});

            // stackIndex++

            for (let subStackLabel of substackLabels) {

              datasets.push({
                label: number_of+' given '+stackField+'='+stackLabel+' & '+substackField+'='+subStackLabel,
                short_label: substackField.substring(0,2).toUpperCase()+'='+subStackLabel,
                data: computeDataset(
                  query_res,
                  (current_label, current_row) => current_row[mainField]==current_label && current_row[stackField]==stackLabel && current_row[substackField]==subStackLabel
                ),
                backgroundColor: rainbow( stackLabels.length, stackLabels.indexOf(stackLabel), 0.5),
                borderColor: rainbow( substackLabels.length*2, substackLabels.indexOf(subStackLabel)*2+1 ),
                borderSkipped: '',
                borderWidth: 2,
                stack: subStackIndexStack,
                // categoryPercentage: (stackLabels.indexOf(stackLabel)+1) / stackLabels.length * 0.8,
                // barPercentage: 0.8,
                yAxisID: yAxisID
              });
              // myChart.update();
              // await new Promise( res => setTimeout(res, 1000));
              
            }//end for subStackLabel of substackLabels

          }//end if length>=3

        }//end for stackLabel of stackLabels

      }//end if length>=2
    
    }//end if length>=1

  }

  

  await new Promise( res => setTimeout(res, 1000));
  let mainField = $('input[name="mainLabel"]:checked').val() 
  {
    let field = $('input[name="firstStackingLabel"]:checked').val()
    let subField = $('input[name="firstSubStackingLabel"]:checked').val()
    let valueOf = $('#firstStackPlottingValue')[0].options[$('#firstStackPlottingValue')[0].selectedIndex].value
    let fields = [mainField]
    if (field!='none')                          fields.push(field)
    if (field!='none' && subField!='disabled')  fields.push(subField)
    if (field!='disabled')                      await plotDataset(fields, 1, valueOf);
  }
  {
    let field = $('input[name="secondStackingLabel"]:checked').val()
    let subField = $('input[name="secondSubStackingLabel"]:checked').val()
    let valueOf = $('#secondStackPlottingValue')[0].options[$('#secondStackPlottingValue')[0].selectedIndex].value
    let fields = [mainField]
    if (field!='none')                          fields.push(field)
    if (field!='none' && subField!='disabled')  fields.push(subField)
    if (field!='disabled')                      await plotDataset(fields, 2, valueOf, 'right-y-axis');
  }



  myChart.data.labels = labels[mainField]
  myChart.data.datasets = datasets
  myChart.options.scales.xAxes[0].scaleLabel.labelString = mainField
  myChart.update();

}
$(document).ready(function(){
  refresh();
})



function rainbow(numOfSteps, step, a=1) {
    // This function generates vibrant, "evenly spaced" colours (i.e. no clustering). This is ideal for creating easily distinguishable vibrant markers in Google Maps and other apps.
    // Adam Cole, 2011-Sept-14
    // HSV to RBG adapted from: http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
    var r, g, b;
    var h = step / numOfSteps;
    var i = ~~(h * 6);
    var f = h * 6 - i;
    var q = 1 - f;
    switch(i % 6){
        case 0: r = 1; g = f; b = 0; break;
        case 1: r = q; g = 1; b = 0; break;
        case 2: r = 0; g = 1; b = f; break;
        case 3: r = 0; g = q; b = 1; break;
        case 4: r = f; g = 0; b = 1; break;
        case 5: r = 1; g = 0; b = q; break;
    }
    r = (~ ~(r * 255))
    g = (~ ~(g * 255))
    b = (~ ~(b * 255))
    var c = "#" + ("00" + (~ ~(r * 255)).toString(16)).slice(-2) + ("00" + (~ ~(g * 255)).toString(16)).slice(-2) + ("00" + (~ ~(b * 255)).toString(16)).slice(-2);
    return ('rgba('+r+', '+g+', '+b+', '+a+')');
}



</script>

</body>

</html>